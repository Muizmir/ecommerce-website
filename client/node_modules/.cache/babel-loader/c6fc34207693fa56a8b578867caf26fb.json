{"ast":null,"code":"\"use strict\";\n\nvar Parser = require(\"fastparse\");\n\nfunction commentMatch(match, content) {\n  this.value.nodes.push({\n    type: \"comment\",\n    content: content\n  });\n}\n\nfunction spacingMatch(match) {\n  var item = this.value.nodes[this.value.nodes.length - 1];\n  item.after = (item.after || \"\") + match;\n}\n\nfunction initialSpacingMatch(match) {\n  this.value.before = match;\n}\n\nfunction endSpacingMatch(match) {\n  this.value.after = match;\n}\n\nfunction unescapeString(content) {\n  return content.replace(/\\\\(?:([a-fA-F0-9]{1,6})|(.))/g, function (all, unicode, otherCharacter) {\n    if (otherCharacter) {\n      return otherCharacter;\n    }\n\n    var C = parseInt(unicode, 16);\n\n    if (C < 0x10000) {\n      return String.fromCharCode(C);\n    } else {\n      return String.fromCharCode(Math.floor((C - 0x10000) / 0x400) + 0xD800) + String.fromCharCode((C - 0x10000) % 0x400 + 0xDC00);\n    }\n  });\n}\n\nfunction stringMatch(match, content) {\n  var value = unescapeString(content);\n  this.value.nodes.push({\n    type: \"string\",\n    value: value,\n    stringType: match[0]\n  });\n}\n\nfunction commaMatch(match, spacing) {\n  var newValue = {\n    type: \"value\",\n    nodes: []\n  };\n\n  if (spacing) {\n    newValue.before = spacing;\n  }\n\n  this.root.nodes.push(newValue);\n  this.value = newValue;\n}\n\nfunction itemMatch(match) {\n  this.value.nodes.push({\n    type: \"item\",\n    name: match\n  });\n}\n\nfunction nestedItemMatch(match, name, spacing) {\n  this.stack.push(this.root);\n  this.root = {\n    type: \"nested-item\",\n    name: name,\n    nodes: [{\n      type: \"value\",\n      nodes: []\n    }]\n  };\n\n  if (spacing) {\n    this.root.nodes[0].before = spacing;\n  }\n\n  this.value.nodes.push(this.root);\n  this.value = this.root.nodes[0];\n}\n\nfunction nestedItemEndMatch(match, spacing, remaining) {\n  if (this.stack.length === 0) {\n    if (spacing) {\n      var item = this.value.nodes[this.value.nodes.length - 1];\n      item.after = (item.after || \"\") + spacing;\n    }\n\n    this.value.nodes.push({\n      type: \"invalid\",\n      value: remaining\n    });\n  } else {\n    if (spacing) {\n      this.value.after = spacing;\n    }\n\n    this.root = this.stack.pop();\n    this.value = this.root.nodes[this.root.nodes.length - 1];\n  }\n}\n\nfunction urlMatch(match, innerSpacingBefore, content, innerSpacingAfter) {\n  var item = {\n    type: \"url\"\n  };\n\n  if (innerSpacingBefore) {\n    item.innerSpacingBefore = innerSpacingBefore;\n  }\n\n  if (innerSpacingAfter) {\n    item.innerSpacingAfter = innerSpacingAfter;\n  }\n\n  switch (content[0]) {\n    case \"\\\"\":\n      item.stringType = \"\\\"\";\n      item.url = unescapeString(content.substr(1, content.length - 2));\n      break;\n\n    case \"'\":\n      item.stringType = \"'\";\n      item.url = unescapeString(content.substr(1, content.length - 2));\n      break;\n\n    default:\n      item.url = unescapeString(content);\n      break;\n  }\n\n  this.value.nodes.push(item);\n}\n\nvar parser = new Parser({\n  decl: {\n    \"^\\\\s+\": initialSpacingMatch,\n    \"/\\\\*([\\\\s\\\\S]*?)\\\\*/\": commentMatch,\n    \"\\\"((?:[^\\\\\\\\\\\"]|\\\\\\\\.)*)\\\"\": stringMatch,\n    \"'((?:[^\\\\\\\\']|\\\\\\\\.)*)'\": stringMatch,\n    \"url\\\\((\\\\s*)(\\\"(?:[^\\\\\\\\\\\"]|\\\\\\\\.)*\\\")(\\\\s*)\\\\)\": urlMatch,\n    \"url\\\\((\\\\s*)('(?:[^\\\\\\\\']|\\\\\\\\.)*')(\\\\s*)\\\\)\": urlMatch,\n    \"url\\\\((\\\\s*)((?:[^\\\\\\\\)'\\\"]|\\\\\\\\.)*)(\\\\s*)\\\\)\": urlMatch,\n    \"([\\\\w-]+)\\\\((\\\\s*)\": nestedItemMatch,\n    \"(\\\\s*)(\\\\))\": nestedItemEndMatch,\n    \",(\\\\s*)\": commaMatch,\n    \"\\\\s+$\": endSpacingMatch,\n    \"\\\\s+\": spacingMatch,\n    \"[^\\\\s,)]+\": itemMatch\n  }\n});\n\nfunction parseValues(str) {\n  var valueNode = {\n    type: \"value\",\n    nodes: []\n  };\n  var rootNode = {\n    type: \"values\",\n    nodes: [valueNode]\n  };\n  parser.parse(\"decl\", str, {\n    stack: [],\n    root: rootNode,\n    value: valueNode\n  });\n  return rootNode;\n}\n\nmodule.exports = parseValues;","map":null,"metadata":{},"sourceType":"script"}