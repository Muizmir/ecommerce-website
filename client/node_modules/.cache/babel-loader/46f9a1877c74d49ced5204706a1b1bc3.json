{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _cssSelectorTokenizer = require('css-selector-tokenizer');\n\nvar _cssSelectorTokenizer2 = _interopRequireDefault(_cssSelectorTokenizer);\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(selectors) {\n  return selectors.nodes.map(function (node) {\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + _cssSelectorTokenizer2['default'].stringify(selectors) + '\"');\n    }\n\n    node = node.nodes[0];\n\n    if (node.type !== 'nested-pseudo-class' || node.name !== 'local' || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + _cssSelectorTokenizer2['default'].stringify(selectors) + '\", \"' + _cssSelectorTokenizer2['default'].stringify(node) + '\" is weird');\n    }\n\n    node = node.nodes[0];\n\n    if (node.type !== 'selector' || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + _cssSelectorTokenizer2['default'].stringify(selectors) + '\", \"' + _cssSelectorTokenizer2['default'].stringify(node) + '\" is weird');\n    }\n\n    node = node.nodes[0];\n\n    if (node.type !== 'class') {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + _cssSelectorTokenizer2['default'].stringify(selectors) + '\", \"' + _cssSelectorTokenizer2['default'].stringify(node) + '\" is weird');\n    }\n\n    return node.name;\n  });\n}\n\nvar processor = _postcss2['default'].plugin('postcss-modules-scope', function (options) {\n  return function (css) {\n    var generateScopedName = options && options.generateScopedName || processor.generateScopedName;\n    var exports = {};\n\n    function exportScopedName(name) {\n      var scopedName = generateScopedName(name, css.source.input.from, css.source.input.css);\n      exports[name] = exports[name] || [];\n\n      if (exports[name].indexOf(scopedName) < 0) {\n        exports[name].push(scopedName);\n      }\n\n      return scopedName;\n    }\n\n    function localizeNode(node) {\n      var newNode = Object.create(node);\n\n      switch (node.type) {\n        case 'selector':\n          newNode.nodes = node.nodes.map(localizeNode);\n          return newNode;\n\n        case 'class':\n        case 'id':\n          var scopedName = exportScopedName(node.name);\n          newNode.name = scopedName;\n          return newNode;\n      }\n\n      throw new Error(node.type + ' (\"' + _cssSelectorTokenizer2['default'].stringify(node) + '\") is not allowed in a :local block');\n    }\n\n    function traverseNode(node) {\n      switch (node.type) {\n        case 'nested-pseudo-class':\n          if (node.name === 'local') {\n            if (node.nodes.length !== 1) {\n              throw new Error('Unexpected comma (\",\") in :local block');\n            }\n\n            return localizeNode(node.nodes[0]);\n          }\n\n        /* falls through */\n\n        case 'selectors':\n        case 'selector':\n          var newNode = Object.create(node);\n          newNode.nodes = node.nodes.map(traverseNode);\n          return newNode;\n      }\n\n      return node;\n    } // Find any :import and remember imported names\n\n\n    var importedNames = {};\n    css.walkRules(function (rule) {\n      if (/^:import\\(.+\\)$/.test(rule.selector)) {\n        rule.walkDecls(function (decl) {\n          importedNames[decl.prop] = true;\n        });\n      }\n    }); // Find any :local classes\n\n    css.walkRules(function (rule) {\n      var selector = _cssSelectorTokenizer2['default'].parse(rule.selector);\n\n      var newSelector = traverseNode(selector);\n      rule.selector = _cssSelectorTokenizer2['default'].stringify(newSelector);\n      rule.walkDecls(/composes|compose-with/, function (decl) {\n        var localNames = getSingleLocalNamesForComposes(selector);\n        var classes = decl.value.split(/\\s+/);\n        classes.forEach(function (className) {\n          var global = /^global\\(([^\\)]+)\\)$/.exec(className);\n\n          if (global) {\n            localNames.forEach(function (exportedName) {\n              exports[exportedName].push(global[1]);\n            });\n          } else if (hasOwnProperty.call(importedNames, className)) {\n            localNames.forEach(function (exportedName) {\n              exports[exportedName].push(className);\n            });\n          } else if (hasOwnProperty.call(exports, className)) {\n            localNames.forEach(function (exportedName) {\n              exports[className].forEach(function (item) {\n                exports[exportedName].push(item);\n              });\n            });\n          } else {\n            throw decl.error('referenced class name \"' + className + '\" in ' + decl.prop + ' not found');\n          }\n        });\n        decl.remove();\n      });\n      rule.walkDecls(function (decl) {\n        var tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n        tokens = tokens.map(function (token, idx) {\n          if (idx === 0 || tokens[idx - 1] === ',') {\n            var localMatch = /^(\\s*):local\\s*\\((.+?)\\)/.exec(token);\n\n            if (localMatch) {\n              return localMatch[1] + exportScopedName(localMatch[2]) + token.substr(localMatch[0].length);\n            } else {\n              return token;\n            }\n          } else {\n            return token;\n          }\n        });\n        decl.value = tokens.join('');\n      });\n    }); // Find any :local keyframes\n\n    css.walkAtRules(function (atrule) {\n      if (/keyframes$/.test(atrule.name)) {\n        var localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atrule.params);\n\n        if (localMatch) {\n          atrule.params = exportScopedName(localMatch[1]);\n        }\n      }\n    }); // If we found any :locals, insert an :export rule\n\n    var exportedNames = Object.keys(exports);\n\n    if (exportedNames.length > 0) {\n      (function () {\n        var exportRule = _postcss2['default'].rule({\n          selector: ':export'\n        });\n\n        exportedNames.forEach(function (exportedName) {\n          return exportRule.append({\n            prop: exportedName,\n            value: exports[exportedName].join(' '),\n            raws: {\n              before: '\\n  '\n            }\n          });\n        });\n        css.append(exportRule);\n      })();\n    }\n  };\n});\n\nprocessor.generateScopedName = function (exportedName, path) {\n  var sanitisedPath = path.replace(/\\.[^\\.\\/\\\\]+$/, '').replace(/[\\W_]+/g, '_').replace(/^_|_$/g, '');\n  return '_' + sanitisedPath + '__' + exportedName;\n};\n\nexports['default'] = processor;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}