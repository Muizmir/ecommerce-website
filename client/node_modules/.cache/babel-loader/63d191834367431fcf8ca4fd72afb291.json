{"ast":null,"code":"var postcss = require('postcss');\n\nvar Tokenizer = require('css-selector-tokenizer');\n\nfunction normalizeNodeArray(nodes) {\n  var array = [];\n  nodes.forEach(function (x) {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(function (item) {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && array[array.length - 1].type === 'spacing') {\n    array.pop();\n  }\n\n  return array;\n}\n\nfunction localizeNode(node, context) {\n  if (context.ignoreNextSpacing && node.type !== 'spacing') {\n    throw new Error('Missing whitespace after :' + context.ignoreNextSpacing);\n  }\n\n  if (context.enforceNoSpacing && node.type === 'spacing') {\n    throw new Error('Missing whitespace before :' + context.enforceNoSpacing);\n  }\n\n  var newNodes;\n\n  switch (node.type) {\n    case 'selectors':\n      var resultingGlobal;\n      context.hasPureGlobals = false;\n      newNodes = node.nodes.map(function (n) {\n        var nContext = {\n          global: context.global,\n          lastWasSpacing: true,\n          hasLocals: false,\n          explicit: false\n        };\n        n = localizeNode(n, nContext);\n\n        if (typeof resultingGlobal === 'undefined') {\n          resultingGlobal = nContext.global;\n        } else if (resultingGlobal !== nContext.global) {\n          throw new Error('Inconsistent rule global/local result in rule \"' + Tokenizer.stringify(node) + '\" (multiple selectors must result in the same mode for the rule)');\n        }\n\n        if (!nContext.hasLocals) {\n          context.hasPureGlobals = true;\n        }\n\n        return n;\n      });\n      context.global = resultingGlobal;\n      node = Object.create(node);\n      node.nodes = normalizeNodeArray(newNodes);\n      break;\n\n    case 'selector':\n      newNodes = node.nodes.map(function (n) {\n        return localizeNode(n, context);\n      });\n      node = Object.create(node);\n      node.nodes = normalizeNodeArray(newNodes);\n      break;\n\n    case 'spacing':\n      if (context.ignoreNextSpacing) {\n        context.ignoreNextSpacing = false;\n        context.lastWasSpacing = false;\n        context.enforceNoSpacing = false;\n        return null;\n      }\n\n      context.lastWasSpacing = true;\n      return node;\n\n    case 'pseudo-class':\n      if (node.name === 'local' || node.name === 'global') {\n        if (context.inside) {\n          throw new Error('A :' + node.name + ' is not allowed inside of a :' + context.inside + '(...)');\n        }\n\n        context.ignoreNextSpacing = context.lastWasSpacing ? node.name : false;\n        context.enforceNoSpacing = context.lastWasSpacing ? false : node.name;\n        context.global = node.name === 'global';\n        context.explicit = true;\n        return null;\n      }\n\n      break;\n\n    case 'nested-pseudo-class':\n      var subContext;\n\n      if (node.name === 'local' || node.name === 'global') {\n        if (context.inside) {\n          throw new Error('A :' + node.name + '(...) is not allowed inside of a :' + context.inside + '(...)');\n        }\n\n        subContext = {\n          global: node.name === 'global',\n          inside: node.name,\n          hasLocals: false,\n          explicit: true\n        };\n        node = node.nodes.map(function (n) {\n          return localizeNode(n, subContext);\n        }); // don't leak spacing\n\n        node[0].before = undefined;\n        node[node.length - 1].after = undefined;\n      } else {\n        subContext = {\n          global: context.global,\n          inside: context.inside,\n          lastWasSpacing: true,\n          hasLocals: false,\n          explicit: context.explicit\n        };\n        newNodes = node.nodes.map(function (n) {\n          return localizeNode(n, subContext);\n        });\n        node = Object.create(node);\n        node.nodes = normalizeNodeArray(newNodes);\n      }\n\n      if (subContext.hasLocals) {\n        context.hasLocals = true;\n      }\n\n      break;\n\n    case 'id':\n    case 'class':\n      if (!context.global) {\n        node = {\n          type: 'nested-pseudo-class',\n          name: 'local',\n          nodes: [node]\n        };\n        context.hasLocals = true;\n      }\n\n      break;\n  } // reset context\n\n\n  context.lastWasSpacing = false;\n  context.ignoreNextSpacing = false;\n  context.enforceNoSpacing = false;\n  return node;\n}\n\nfunction localizeDeclNode(node, context) {\n  var newNode;\n\n  switch (node.type) {\n    case 'item':\n      if (context.localizeNextItem) {\n        newNode = Object.create(node);\n        newNode.name = ':local(' + newNode.name + ')';\n        context.localizeNextItem = false;\n        return newNode;\n      }\n\n      break;\n\n    case 'nested-item':\n      var newNodes = node.nodes.map(function (n) {\n        return localizeDeclValue(n, context);\n      });\n      node = Object.create(node);\n      node.nodes = newNodes;\n      break;\n\n    case 'url':\n      if (context.options && context.options.rewriteUrl) {\n        newNode = Object.create(node);\n        newNode.url = context.options.rewriteUrl(context.global, node.url);\n        return newNode;\n      }\n\n      break;\n  }\n\n  return node;\n}\n\nfunction localizeDeclValue(valueNode, context) {\n  var newValueNode = Object.create(valueNode);\n  newValueNode.nodes = valueNode.nodes.map(function (node) {\n    return localizeDeclNode(node, context);\n  });\n  return newValueNode;\n}\n\nfunction localizeAnimationShorthandDeclValueNodes(nodes, context) {\n  var validIdent = validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n  /*\n  The spec defines some keywords that you can use to describe properties such as the timing\n  function. These are still valid animation names, so as long as there is a property that accepts\n  a keyword, it is given priority. Only when all the properties that can take a keyword are\n  exhausted can the animation name be set to the keyword. I.e.\n   animation: infinite infinite;\n   The animation will repeat an infinite number of times from the first argument, and will have an\n  animation name of infinite from the second.\n  */\n\n  var animationKeywords = {\n    '$alternate': 1,\n    '$alternate-reverse': 1,\n    '$backwards': 1,\n    '$both': 1,\n    '$ease': 1,\n    '$ease-in': 1,\n    '$ease-in-out': 1,\n    '$ease-out': 1,\n    '$forwards': 1,\n    '$infinite': 1,\n    '$linear': 1,\n    '$none': Infinity,\n    // No matter how many times you write none, it will never be an animation name\n    '$normal': 1,\n    '$paused': 1,\n    '$reverse': 1,\n    '$running': 1,\n    '$step-end': 1,\n    '$step-start': 1,\n    '$initial': Infinity,\n    '$inherit': Infinity,\n    '$unset': Infinity\n  };\n  var didParseAnimationName = false;\n  var parsedAnimationKeywords = {};\n  return nodes.map(function (valueNode) {\n    var value = valueNode.type === 'item' ? valueNode.name.toLowerCase() : null;\n    var shouldParseAnimationName = false;\n\n    if (!didParseAnimationName && value && validIdent.test(value)) {\n      if ('$' + value in animationKeywords) {\n        parsedAnimationKeywords['$' + value] = '$' + value in parsedAnimationKeywords ? parsedAnimationKeywords['$' + value] + 1 : 0;\n        shouldParseAnimationName = parsedAnimationKeywords['$' + value] >= animationKeywords['$' + value];\n      } else {\n        shouldParseAnimationName = true;\n      }\n    }\n\n    var subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: shouldParseAnimationName && !context.global\n    };\n    return localizeDeclNode(valueNode, subContext);\n  });\n}\n\nfunction localizeAnimationShorthandDeclValues(valuesNode, decl, context) {\n  var newValuesNode = Object.create(valuesNode);\n  newValuesNode.nodes = valuesNode.nodes.map(function (valueNode, index) {\n    var newValueNode = Object.create(valueNode);\n    newValueNode.nodes = localizeAnimationShorthandDeclValueNodes(valueNode.nodes, context);\n    return newValueNode;\n  });\n  decl.value = Tokenizer.stringifyValues(newValuesNode);\n}\n\nfunction localizeDeclValues(localize, valuesNode, decl, context) {\n  var newValuesNode = Object.create(valuesNode);\n  newValuesNode.nodes = valuesNode.nodes.map(function (valueNode) {\n    var subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global\n    };\n    return localizeDeclValue(valueNode, subContext);\n  });\n  decl.value = Tokenizer.stringifyValues(newValuesNode);\n}\n\nfunction localizeDecl(decl, context) {\n  var valuesNode = Tokenizer.parseValues(decl.value);\n  var isAnimation = /animation?$/.test(decl.prop);\n  if (isAnimation) return localizeAnimationShorthandDeclValues(valuesNode, decl, context);\n  var isAnimationName = /animation(-name)?$/.test(decl.prop);\n  if (isAnimationName) return localizeDeclValues(true, valuesNode, decl, context);\n  return localizeDeclValues(false, valuesNode, decl, context);\n}\n\nmodule.exports = postcss.plugin('postcss-modules-local-by-default', function (options) {\n  if (typeof options !== 'object') {\n    options = {}; // If options is undefined or not an object the plugin fails\n  }\n\n  if (options && options.mode) {\n    if (options.mode !== 'global' && options.mode !== 'local' && options.mode !== 'pure') {\n      throw new Error('options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")');\n    }\n  }\n\n  var pureMode = options && options.mode === 'pure';\n  var globalMode = options && options.mode === 'global';\n  return function (css) {\n    css.walkAtRules(function (atrule) {\n      if (/keyframes$/.test(atrule.name)) {\n        var globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        var localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atrule.params);\n        var globalKeyframes = globalMode;\n\n        if (globalMatch) {\n          if (pureMode) {\n            throw atrule.error('@keyframes :global(...) is not allowed in pure mode');\n          }\n\n          atrule.params = globalMatch[1];\n          globalKeyframes = true;\n        } else if (localMatch) {\n          atrule.params = localMatch[0];\n          globalKeyframes = false;\n        } else if (!globalMode) {\n          atrule.params = ':local(' + atrule.params + ')';\n        }\n\n        atrule.walkDecls(function (decl) {\n          localizeDecl(decl, {\n            options: options,\n            global: globalKeyframes\n          });\n        });\n      } else if (atrule.nodes) {\n        atrule.nodes.forEach(function (decl) {\n          if (decl.type === 'decl') {\n            localizeDecl(decl, {\n              options: options,\n              global: globalMode\n            });\n          }\n        });\n      }\n    });\n    css.walkRules(function (rule) {\n      if (rule.parent.type === 'atrule' && /keyframes$/.test(rule.parent.name)) {\n        // ignore keyframe rules\n        return;\n      }\n\n      var selector = Tokenizer.parse(rule.selector);\n      var context = {\n        options: options,\n        global: globalMode,\n        hasPureGlobals: false\n      };\n      var newSelector;\n\n      try {\n        newSelector = localizeNode(selector, context);\n      } catch (e) {\n        throw rule.error(e.message);\n      }\n\n      if (pureMode && context.hasPureGlobals) {\n        throw rule.error('Selector \"' + Tokenizer.stringify(selector) + '\" is not pure ' + '(pure selectors must contain at least one local class or id)');\n      } // Less-syntax mixins parse as rules with no nodes\n\n\n      if (rule.nodes) {\n        rule.nodes.forEach(function (decl) {\n          localizeDecl(decl, context);\n        });\n      }\n\n      rule.selector = Tokenizer.stringify(newSelector);\n    });\n  };\n});","map":null,"metadata":{},"sourceType":"script"}