{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nfunction ignoreFunction() {}\n\nfunction createReturningFunction(value) {\n  return function () {\n    return value;\n  };\n}\n\nfunction Parser(states) {\n  this.states = this.compileStates(states);\n}\n\nParser.prototype.compileStates = function (states) {\n  var result = {};\n  Object.keys(states).forEach(function (name) {\n    result[name] = this.compileState(states[name], states);\n  }, this);\n  return result;\n};\n\nParser.prototype.compileState = function (state, states) {\n  var regExps = [];\n\n  function iterator(str, value) {\n    regExps.push({\n      groups: Parser.getGroupCount(str),\n      regExp: str,\n      value: value\n    });\n  }\n\n  function processState(statePart) {\n    if (Array.isArray(statePart)) {\n      statePart.forEach(processState);\n    } else if (typeof statePart === \"object\") {\n      Object.keys(statePart).forEach(function (key) {\n        iterator(key, statePart[key]);\n      });\n    } else if (typeof statePart === \"string\") {\n      processState(states[statePart]);\n    } else {\n      throw new Error(\"Unexpected 'state' format\");\n    }\n  }\n\n  processState(state);\n  var total = regExps.map(function (r) {\n    return \"(\" + r.regExp + \")\";\n  }).join(\"|\");\n  var actions = [];\n  var pos = 1;\n  regExps.forEach(function (r) {\n    var fn;\n\n    if (typeof r.value === \"function\") {\n      fn = r.value;\n    } else if (typeof r.value === \"string\") {\n      fn = createReturningFunction(r.value);\n    } else {\n      fn = ignoreFunction;\n    }\n\n    actions.push({\n      name: r.regExp,\n      fn: fn,\n      pos: pos,\n      pos2: pos + r.groups + 1\n    });\n    pos += r.groups + 1;\n  });\n  return {\n    regExp: new RegExp(total, \"g\"),\n    actions: actions\n  };\n};\n\nParser.getGroupCount = function (regExpStr) {\n  return new RegExp(\"(\" + regExpStr + \")|^$\").exec(\"\").length - 2;\n};\n\nParser.prototype.parse = function (initialState, string, context) {\n  context = context || {};\n  var currentState = initialState;\n  var currentIndex = 0;\n\n  for (;;) {\n    var state = this.states[currentState];\n    var regExp = state.regExp;\n    regExp.lastIndex = currentIndex;\n    var match = regExp.exec(string);\n    if (!match) return context;\n    var actions = state.actions;\n    currentIndex = state.regExp.lastIndex;\n\n    for (var i = 0; i < actions.length; i++) {\n      var action = actions[i];\n\n      if (match[action.pos]) {\n        var ret = action.fn.apply(context, Array.prototype.slice.call(match, action.pos, action.pos2).concat([state.regExp.lastIndex - match[0].length, match[0].length]));\n\n        if (ret) {\n          if (!(ret in this.states)) throw new Error(\"State '\" + ret + \"' doesn't exist\");\n          currentState = ret;\n        }\n\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}