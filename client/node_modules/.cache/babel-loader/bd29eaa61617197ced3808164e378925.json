{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _postcss = require('postcss');\n\nvar _postcss2 = _interopRequireDefault(_postcss);\n\nvar _icssReplaceSymbols = require('icss-replace-symbols');\n\nvar _icssReplaceSymbols2 = _interopRequireDefault(_icssReplaceSymbols);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nvar matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nvar matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nvar options = {};\nvar importIndex = 0;\n\nvar createImportedName = options && options.createImportedName || function (importName\n/*, path*/\n) {\n  return 'i__const_' + importName.replace(/\\W/g, '_') + '_' + importIndex++;\n};\n\nexports.default = _postcss2.default.plugin('postcss-modules-values', function () {\n  return function (css, result) {\n    var importAliases = [];\n    var definitions = {};\n\n    var addDefinition = function addDefinition(atRule) {\n      var matches = void 0;\n\n      while (matches = matchValueDefinition.exec(atRule.params)) {\n        var _matches = matches;\n\n        var _matches2 = _slicedToArray(_matches, 3);\n\n        var\n        /*match*/\n        key = _matches2[1];\n        var value = _matches2[2]; // Add to the definitions, knowing that values can refer to each other\n\n        definitions[key] = (0, _icssReplaceSymbols.replaceAll)(definitions, value);\n        atRule.remove();\n      }\n    };\n\n    var addImport = function addImport(atRule) {\n      var matches = matchImports.exec(atRule.params);\n\n      if (matches) {\n        var _matches3 = _slicedToArray(matches, 3);\n\n        var\n        /*match*/\n        aliases = _matches3[1];\n        var path = _matches3[2]; // We can use constants for path names\n\n        if (definitions[path]) path = definitions[path];\n        var imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1').split(/\\s*,\\s*/).map(function (alias) {\n          var tokens = matchImport.exec(alias);\n\n          if (tokens) {\n            var _tokens = _slicedToArray(tokens, 3);\n\n            var\n            /*match*/\n            theirName = _tokens[1];\n            var _tokens$ = _tokens[2];\n            var myName = _tokens$ === undefined ? theirName : _tokens$;\n            var importedName = createImportedName(myName);\n            definitions[myName] = importedName;\n            return {\n              theirName: theirName,\n              importedName: importedName\n            };\n          } else {\n            throw new Error('@import statement \"' + alias + '\" is invalid!');\n          }\n        });\n        importAliases.push({\n          path: path,\n          imports: imports\n        });\n        atRule.remove();\n      }\n    };\n    /* Look at all the @value statements and treat them as locals or as imports */\n\n\n    css.walkAtRules('value', function (atRule) {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n     it well get picked up by the replacement stuff */\n\n    var exportDeclarations = Object.keys(definitions).map(function (key) {\n      return _postcss2.default.decl({\n        value: definitions[key],\n        prop: key,\n        raws: {\n          before: \"\\n  \"\n        }\n      });\n    });\n    /* If we have no definitions, don't continue */\n\n    if (!Object.keys(definitions).length) return;\n    /* Perform replacements */\n\n    (0, _icssReplaceSymbols2.default)(css, definitions);\n    /* Add export rules if any */\n\n    if (exportDeclarations.length > 0) {\n      var exportRule = _postcss2.default.rule({\n        selector: ':export',\n        raws: {\n          after: \"\\n\"\n        }\n      });\n\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n    /* Add import rules */\n\n\n    importAliases.reverse().forEach(function (_ref) {\n      var path = _ref.path;\n      var imports = _ref.imports;\n\n      var importRule = _postcss2.default.rule({\n        selector: ':import(' + path + ')',\n        raws: {\n          after: \"\\n\"\n        }\n      });\n\n      imports.forEach(function (_ref2) {\n        var theirName = _ref2.theirName;\n        var importedName = _ref2.importedName;\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: {\n            before: \"\\n  \"\n          }\n        });\n      });\n      css.prepend(importRule);\n    });\n  };\n});\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}