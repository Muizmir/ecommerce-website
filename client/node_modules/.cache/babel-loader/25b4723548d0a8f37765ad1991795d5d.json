{"ast":null,"code":"\"use strict\";\n\nvar Parser = require(\"fastparse\");\n\nvar regexpu = require(\"regexpu-core\");\n\nfunction unescape(str) {\n  return str.replace(/\\\\(.)/g, \"$1\");\n}\n\nfunction commentMatch(match, content) {\n  this.selector.nodes.push({\n    type: \"comment\",\n    content: content\n  });\n}\n\nfunction typeMatch(type) {\n  return function (match, name) {\n    this.selector.nodes.push({\n      type: type,\n      name: unescape(name)\n    });\n  };\n}\n\nfunction pseudoClassStartMatch(match, name) {\n  var newToken = {\n    type: \"pseudo-class\",\n    name: unescape(name),\n    content: \"\"\n  };\n  this.selector.nodes.push(newToken);\n  this.token = newToken;\n  this.brackets = 1;\n  return \"inBrackets\";\n}\n\nfunction nestedPseudoClassStartMatch(match, name, after) {\n  var newSelector = {\n    type: \"selector\",\n    nodes: []\n  };\n  var newToken = {\n    type: \"nested-pseudo-class\",\n    name: unescape(name),\n    nodes: [newSelector]\n  };\n\n  if (after) {\n    newSelector.before = after;\n  }\n\n  this.selector.nodes.push(newToken);\n  this.stack.push(this.root);\n  this.root = newToken;\n  this.selector = newSelector;\n}\n\nfunction nestedEnd(match, before) {\n  if (this.stack.length > 0) {\n    if (before) {\n      this.selector.after = before;\n    }\n\n    this.root = this.stack.pop();\n    this.selector = this.root.nodes[this.root.nodes.length - 1];\n  } else {\n    this.selector.nodes.push({\n      type: \"invalid\",\n      value: match\n    });\n  }\n}\n\nfunction operatorMatch(match, before, operator, after) {\n  var token = {\n    type: \"operator\",\n    operator: operator\n  };\n\n  if (before) {\n    token.before = before;\n  }\n\n  if (after) {\n    token.after = after;\n  }\n\n  this.selector.nodes.push(token);\n}\n\nfunction spacingMatch(match) {\n  this.selector.nodes.push({\n    type: \"spacing\",\n    value: match\n  });\n}\n\nfunction elementMatch(match, namespace, name) {\n  var newToken = {\n    type: \"element\",\n    name: unescape(name)\n  };\n\n  if (namespace) {\n    newToken.namespace = unescape(namespace.substr(0, namespace.length - 1));\n  }\n\n  this.selector.nodes.push(newToken);\n}\n\nfunction universalMatch(match, namespace) {\n  var newToken = {\n    type: \"universal\"\n  };\n\n  if (namespace) {\n    newToken.namespace = unescape(namespace.substr(0, namespace.length - 1));\n  }\n\n  this.selector.nodes.push(newToken);\n}\n\nfunction attributeMatch(match, content) {\n  this.selector.nodes.push({\n    type: \"attribute\",\n    content: content\n  });\n}\n\nfunction invalidMatch(match) {\n  this.selector.nodes.push({\n    type: \"invalid\",\n    value: match\n  });\n}\n\nfunction irrelevantSpacingStartMatch(match) {\n  this.selector.before = match;\n}\n\nfunction irrelevantSpacingEndMatch(match) {\n  this.selector.after = match;\n}\n\nfunction nextSelectorMatch(match, before, after) {\n  var newSelector = {\n    type: \"selector\",\n    nodes: []\n  };\n\n  if (before) {\n    this.selector.after = before;\n  }\n\n  if (after) {\n    newSelector.before = after;\n  }\n\n  this.root.nodes.push(newSelector);\n  this.selector = newSelector;\n}\n\nfunction addToCurrent(match) {\n  this.token.content += match;\n}\n\nfunction bracketStart(match) {\n  this.token.content += match;\n  this.brackets++;\n}\n\nfunction bracketEnd(match) {\n  if (--this.brackets === 0) {\n    return \"selector\";\n  }\n\n  this.token.content += match;\n}\n\nfunction getSelectors() {\n  // The assignment here is split to preserve the property enumeration order.\n  var selectors = {\n    \"/\\\\*([\\\\s\\\\S]*?)\\\\*/\": commentMatch\n  }; // https://www.w3.org/TR/CSS21/syndata.html#characters\n  // 4.1.3: identifiers (...) can contain only the characters [a-zA-Z0-9] and\n  // ISO 10646 characters U+00A0 and higher, plus the hyphen (-) and the underscore (_)\n  //\n  // 10ffff is the maximum allowed in current Unicode\n\n  selectors[regexpu(\"\\\\.((?:\\\\\\\\.|[A-Za-z_\\\\-\\\\u{00a0}-\\\\u{10ffff}])(?:\\\\\\\\.|[A-Za-z_\\\\-0-9\\\\u{00a0}-\\\\u{10ffff}])*)\", \"u\")] = typeMatch(\"class\");\n  selectors[regexpu(\"#((?:\\\\\\\\.|[A-Za-z_\\\\-\\\\u{00a0}-\\\\u{10ffff}])(?:\\\\\\\\.|[A-Za-z_\\\\-0-9\\\\u{00a0}-\\\\u{10ffff}])*)\", \"u\")] = typeMatch(\"id\");\n  var selectorsSecondHalf = {\n    \":(not|matches|has|local|global)\\\\((\\\\s*)\": nestedPseudoClassStartMatch,\n    \":((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\\\\(\": pseudoClassStartMatch,\n    \":((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\": typeMatch(\"pseudo-class\"),\n    \"::((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\": typeMatch(\"pseudo-element\"),\n    \"(\\\\*\\\\|)((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\": elementMatch,\n    \"(\\\\*\\\\|)\\\\*\": universalMatch,\n    \"((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*\\\\|)?\\\\*\": universalMatch,\n    \"((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*\\\\|)?((?:\\\\\\\\.|[A-Za-z_\\\\-])(?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*)\": elementMatch,\n    \"\\\\[([^\\\\]]+)\\\\]\": attributeMatch,\n    \"(\\\\s*)\\\\)\": nestedEnd,\n    \"(\\\\s*)((?:\\\\|\\\\|)|(?:>>)|[>+~])(\\\\s*)\": operatorMatch,\n    \"(\\\\s*),(\\\\s*)\": nextSelectorMatch,\n    \"\\\\s+$\": irrelevantSpacingEndMatch,\n    \"^\\\\s+\": irrelevantSpacingStartMatch,\n    \"\\\\s+\": spacingMatch,\n    \".\": invalidMatch\n  };\n  var selector;\n\n  for (selector in selectorsSecondHalf) {\n    if (Object.prototype.hasOwnProperty.call(selectorsSecondHalf, selector)) {\n      selectors[selector] = selectorsSecondHalf[selector];\n    }\n  }\n\n  return selectors;\n}\n\nvar parser = new Parser({\n  selector: getSelectors(),\n  inBrackets: {\n    \"/\\\\*[\\\\s\\\\S]*?\\\\*/\": addToCurrent,\n    \"\\\"([^\\\\\\\\\\\"]|\\\\\\\\.)*\\\"\": addToCurrent,\n    \"'([^\\\\\\\\']|\\\\\\\\.)*'\": addToCurrent,\n    \"[^()'\\\"/]+\": addToCurrent,\n    \"\\\\(\": bracketStart,\n    \"\\\\)\": bracketEnd,\n    \".\": addToCurrent\n  }\n});\n\nfunction parse(str) {\n  var selectorNode = {\n    type: \"selector\",\n    nodes: []\n  };\n  var rootNode = {\n    type: \"selectors\",\n    nodes: [selectorNode]\n  };\n  parser.parse(\"selector\", str, {\n    stack: [],\n    root: rootNode,\n    selector: selectorNode\n  });\n  return rootNode;\n}\n\nmodule.exports = parse;","map":null,"metadata":{},"sourceType":"script"}